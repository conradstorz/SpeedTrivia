# -*- coding: utf-8 -*-
"""SpeedTriva takes input from individual players via SMS using Twillio service.
Players can send their name by text and get back the names of their teammates.
Teams are "Randomly" assigned. 
This app tracks players from past events and strives to assign players together
that have not been at the same table before (like speed dating). 
Player can provide their personal name to the app and include a +1 (or +2 or more) 
to their name to reserve extra seats at their table.
FUNCTIONALITY:
    Incoming SMS;
        First ever incoming SMS becomes Control-Node.
            After that all new numbers are considered players.
                (Control is also player)
        Players can provide details like:
            Name, Team Size(are they alone or have brought partner(s)), 
            Whois (responds with names of other players assigned to table),
            Decline (Ask to be reassigned to different table),
            Team-Name (set it or ask for it), Name-suggestions (offer silly team name),
        Control can provide same as above, plus;
            Shuffle (re-shuffles players), Set-size (set the target size of each table),
            Table-list (returns list of all players and assignments),
            Send-Assignments (sends each player their tablename (e.g. epsilon, gamma, delta...)),

MINIMUM FUNCTIONALITY:
    Default table size equals 4.
    Incoming SMS is placed in the database and body of SMS is used as name and +n value.
        duplicate SMS phone numbers just updates the name and +n values.
    Control can Shuffle tables and send assignments to players.
    No stateful memory is needed between nights a this level.

CRAZY FUTURE FUNCTIONALITY:
    Player can provide the answer to the trivia question by SMS and SpeedTrivia will submit it 
    to the trivia host by filling in the jotform used for answers that night.

    Controller can provide actual answers for storage in the database and matching to the provided
    answers from the teams to keep score automatically within the app. (Alternately the player can
    tell SpeedTrivia when they get a question right so the score can be kept.)

# NOTE: On 4-8-2021 I decided to use PythonAnywhere.com to host this code. 
    It can be accessed at Conradical.pythonanywhere.com/sms
    Twilio.com sends incoming texts from the number (812)203-8235 to the address above.
    The resulting string generated by sms_reply() is then returned to the player.
    An empty string from sms_reply() returns nothing and generates no return text.
    At this time I do not use environment variables at PA.com
    I simply cut and paste the un-encrypted secrets into the code at PA.com
    That code doesn't get pushed to GIT ever so the secrets are fairly safe.

# NOTE: Reading the Twilio website I learned about ngrok.exe
    ngrok is available for all computer platforms and creates tunnels from localhost to the public internet.
    Using ngrok allows testing servers like flask running on localhost with internet resources like Twilio.
    During developement of a webapp like SpeedTriva ngrok allows me to point Twilio at my localhost for testing.
    Deployment to production can then point Twilio back to Conradical.pythonAnywhere.com 
    
"""
from pathlib import Path
FILENAME = __file__
FILENAME_PATHOBJ = Path(__file__)
TWILLIO_SMS_NUMBER = "+18122038235" # Paoli native number bought from Twilio
DATABASE_PATHOBJ = Path("".join([FILENAME, '.db']))

# Download the twilio-python library from twilio.com/docs/libraries/python
import os
import sys
from twilio.rest import Client
from flask import Flask, request, redirect
from twilio.twiml.messaging_response import MessagingResponse
from loguru import logger
from pprint import pformat as pprint_dicts
import datetime as dt
import pytz
import nltk
nltk.download('punkt')
nltk.download('stopwords')
nltk.download('averaged_perceptron_tagger')
from nltk.corpus import stopwords 

from collections import defaultdict
def dict_default():
    sample_player_dict = {
        'Caller_name': '',
        'First_call': None,
        'Recent_call': None,
        'Plus_one': int(0), # represents number of extra seats reserved at the table
        'Partners_history': [],
        'Message_history': [],
    }
    return sample_player_dict
players_database = defaultdict(dict_default)
players_database['root'] = 'root'


# Begin logging definition
logger.remove()  # removes the default console logger provided by Loguru.
# I find it to be too noisy with details more appropriate for file logging.
# create a new log file for each run of the program
logger.add(
    "".join([FILENAME, "_{time}.log"]),
    rotation="Sunday",
    level="DEBUG",
    encoding="utf8"
)
# end logging setup
logger.debug('Program started.')


# Save a dictionary into a pickle file.
import pickle
# pickle.dump( players_database, open( DATABASE_PATHOBJ, "wb" ) )
# retrieve database:
# players_database = pickle.load( open( DATABASE_PATHOBJ, "rb" ) )
if DATABASE_PATHOBJ.exists():
    logger.debug('Recovering pickle database...')
    players_database = pickle.load( open( DATABASE_PATHOBJ, "rb" ) )
else:
    logger.debug('Creating new pickle database...')
    pickle.dump( players_database, open( DATABASE_PATHOBJ, "wb" ) )
    


# Twilio token setup:
CLIENT = None
if not os.system("set ACCOUNT_SID"): # are these return values inverted?
    logger.debug('Twilio ACCOUNT_SID found.')
    if not os.system("set AUTH_TOKEN"): # seems like they would be true if the value exists.
        logger.debug('Twilio AUTH_TOKEN found, registering Twilio Client...')
        ACCOUNT_SID = os.environ.get('ACCOUNT_SID')
        AUTH_TOKEN = os.environ.get('AUTH_TOKEN')
        CLIENT = Client(ACCOUNT_SID, AUTH_TOKEN)
        logger.debug('Client token created:')
        logger.debug(CLIENT)
if CLIENT == None:
    print('Client token not set. Did you load the environment variables?')
    print('Did you re-start VScode?')
    sys.exit(1)


logger.debug('Instantiating Flask App:')
# Instantiate the Flask app
SpeedTriviaApp = Flask(__name__)
logger.debug(SpeedTriviaApp)

# Basic test functionality roadmap:
#   Create a public facing Flask server.
#   Accept SMS messages, Place in local perm storage, reply to SMS with greeting.

@SpeedTriviaApp.route("/sms", methods=["GET", "POST"])
def sms_reply():
    """Respond to incoming calls.
        This is the entrypoint for SpeedTrivia functionality.
    """
    logger.debug('Message received:')
    sms_body = request.values.get('Body', None)
    sms_from = request.values.get('From', None)
    sms_MSID = request.values.get('MessageSid', None)
    logger.debug(sms_MSID)
    logger.debug(sms_from)
    logger.debug(sms_body)
    # Start our TwiML response by creating a new response object.
    sms_response = MessagingResponse()
    logger.debug(sms_response)
    # Generate an appropriate response (if any)
    reply = Respond_to(sms_MSID, sms_from, sms_body)
    if reply == '':
        logger.debug('No response needed.')
    else:
        logger.debug(reply)
    sms_response.message(reply)
    logger.debug(str(sms_response))
    logger.debug('Updating database...')
    pickle.dump( players_database, open( DATABASE_PATHOBJ, "wb" ) )
    logger.debug('Returning control to Flask.')
    return str(sms_response)


def Respond_to(msid, sms_from, body_of_sms):
    response = update_caller_database(msid, sms_from, body_of_sms)
    logger.debug(pprint_dicts(players_database[sms_from]))
    return response


def update_caller_database(msid, sms_from, body_of_sms):
    response = "The Robots are coming!  LoL  Head for the hills "
    response = ''.join([response, players_database[sms_from]['Caller_name']])
    players_database[sms_from]['Message_history'].append((body_of_sms, msid))
    logger.debug(''.join(["Caller's Name: ", players_database[sms_from]['Caller_name']]))
    if players_database[sms_from]['First_call'] == None:
        logger.debug('First time caller.')
        players_database[sms_from]['First_call'] = dt.datetime.now(pytz.timezone("UTC"))
        response = ask_caller_their_name()
        players_database[sms_from]['Recent_call'] = dt.datetime.now(pytz.timezone("UTC"))
    else:
        if players_database[sms_from]['Caller_name'] == '':
            response = check_sms_for_name(msid, sms_from, body_of_sms)
        players_database[sms_from]['Recent_call'] = dt.datetime.now(pytz.timezone("UTC"))    
    return response


def ask_caller_their_name():
    logger.debug('Asking the caller their name.')
    return "Hello! I don't have your number in my records. Could you please tell me your name?"


def check_sms_for_name(msid, sms_from, body_of_sms):
    # Function to extract the proper nouns 
    def ProperNounExtractor(text):
        sentences = nltk.sent_tokenize(text)
        for sentence in sentences:
            words = nltk.word_tokenize(sentence)
            words = [word for word in words if word not in set(stopwords.words('english'))]
            tagged = nltk.pos_tag(words)
            for (word, tag) in tagged:
                if tag == 'NNP': # If the word is a proper noun
                    return word
        return None
    logger.debug('Searching the sms for the callers name.')
    callername = ProperNounExtractor(body_of_sms)
    if callername != None:
        logger.debug('Found a name:')
        logger.debug(callername)
        players_database[sms_from]['Caller_name'] = callername
    else:
        logger.debug("Couldn't find a name.")
        return "Sorry. I didn't understand.  Please try again. Feel free to speak in full sentences."
    return "".join(['Thanks ', callername, '! Glad to meet you. Welcome to SpeedTrivia.'])



if __name__ == "__main__":
    logger.debug('Program is being run as __main__')
    SpeedTriviaApp.run(debug=True)
