# -*- coding: utf-8 -*-
"""SpeedTriva takes input from individual players via SMS using Twillio service.
Players can send their name by text and get back the names of their teammates.
Teams are "Randomly" assigned. 
This app tracks players from past events and strives to assign players together
that have not been at the same table before (like speed dating). 
Player can provide their personal name to the app and include a +1 (or +2 or more) 
to their name to reserve extra seats at their table.
FUNCTIONALITY:
    Incoming SMS;
        First ever incoming SMS becomes Control-Node.
            After that all new numbers are considered players.
                (Control is also player)
        Players can provide details like:
            Name, Team Size(are they alone or have brought partner(s)), 
            Whois (responds with names of other players assigned to table),
            Decline (Ask to be reassigned to different table),
            Team-Name (set it or ask for it), Name-suggestions (offer silly team name),
        Control can provide same as above, plus;
            Shuffle (re-shuffles players), Set-size (set the target size of each table),
            Table-list (returns list of all players and assignments),
            Send-Assignments (sends each player their tablename (e.g. epsilon, gamma, delta...)),

MINIMUM FUNCTIONALITY:
    Default table size equals 4.
    Incoming SMS is placed in the database and body of SMS is used as name and +n value.
        duplicate SMS phone numbers just updates the name and +n values.
    Control can Shuffle tables and send assignments to players.
    No stateful memory is needed between nights a this level.

CRAZY FUTURE FUNCTIONALITY:
    Player can provide the answer to the trivia question by SMS and SpeedTrivia will submit it 
    to the trivia host by filling in the jotform used for answers that night.

    Controller can provide actual answers for storage in the database and matching to the provided
    answers from the teams to keep score automatically within the app. (Alternately the player can
    tell SpeedTrivia when they get a question right so the score can be kept.)

# NOTE: On 4-8-2021 I decided to use PythonAnywhere.com to host this code. 
    It can be accessed at Conradical.pythonanywhere.com/sms
    Twilio.com sends incoming texts from the number (812)203-8235 to the address above.
    The resulting string generated by sms_reply() is then returned to the player.
    An empty string from sms_reply() returns nothing and generates no return text.
    At this time I do not use environment variables at PA.com
    I simply cut and paste the un-encrypted secrets into the code at PA.com
    That code doesn't get pushed to GIT ever so the secrets are fairly safe.

# NOTE: Reading the Twilio website I learned about ngrok.exe
    ngrok is available for all computer platforms and creates tunnels from localhost to the public internet.
    Using ngrok allows testing servers like flask running on localhost with internet resources like Twilio.
    During developement of a webapp like SpeedTriva ngrok allows me to point Twilio at my localhost for testing.
    Deployment to production can then point Twilio back to Conradical.pythonAnywhere.com 
    
"""


""" 5/10/24 ChatGPT reorganized code of main loop """
import sys
from flask import Flask
import datetime as dt
import pickle
from loguru import logger
from ST_functions import *

# Constants
FILENAME = "logfile"
PROGRAM_START_TIME = dt.now()
# TODO command strings and their associated functions need to be declared seperately so that i can break up functions into different files avoid circular references
# TODO example, COMMANDS = {'WebForm': None, 'Status': None, ...}
# TODO so if any string is equal to None then the function has not yet been defined
COMMANDS = {
    "Commands": ReturnListOfCommands,  # return this list of keys.
    "Webform": Send_Webform_help,  # provide a clickable link to the webform.
    "Common": Send_common_commands_help,  # provide help using most common commands.
    "Minus": RemoveReservation,  # remove a +1 from the caller's table.
    "Table": ReturnTableName,  # return callers table name.
    "Status": ReturnStatus,  # return caller status info.
    "Plus": AddReservation,  # add another +1 to the caller's table.
    "Funny": SuggestFunny,  # return a random "funny" team name from a list.
    "Serious": SuggestSerious,  # return a "serious" team name.
    "ChangeName": ChangePlayerName,  # delete the player name and ask for a new one.
    "ChangeTeam": SetTeamName,  # delete the team name and ask for a new one.
    "time": ReturnHelpInfo,  # return the HELP file with info on start time of game.
    "Helpme": ReturnHelpInfo,  # return the HELP file with info on using the app.
    "Shuffle": ShuffleTables,  # CONTROLLER ONLY: re-shuffle table assignments.
    "Start": StartGame,  # CONTROLLER ONLY: Lock-in the table assignments for this game night.
    "Size": ChangeTeamSize,  # CONTROLLER ONLY: Change the number of players per table.
    "Announcement": Send_Announcement,  # CONTROLLER ONLY: Make a SMS note to all registered players.
    "PlayersList": Send_players_list,  # CONTROLLER ONLY: Return a list of ALL players to CONTROLLER.
}
CONTROLLER_ONLY_COMMANDS = [
    "Announcement",
    "PlayersList",
    "Shuffle",
    "Start",
    "Size",
]

# Command Functions
def ReturnListOfCommands(msid, sms_from, body_of_sms):
    # Return a list of available commands.
    return str(COMMANDS.keys())

# Add more command function definitions here like Send_Webform_help, Send_common_commands_help, etc.

# Main Logic
def setup_logger():
    # Sets up the logging system.
    logger.remove()  # Remove the default console logger
    log_filename = f"{FILENAME}_{PROGRAM_START_TIME.strftime('%Y%m%d_%H%M%S%Z')}.log"
    logger.add(log_filename, rotation="Sunday", level="DEBUG", encoding="utf8")
    logger.info("Logging setup complete.")

def create_flask_app():
    # Create and configure the Flask application.
    ST_app = Flask(__name__)

    @ST_app.route("/sms", methods=["GET", "POST"])
    def sms_reply():
        # Handle incoming SMS requests.
        # recover SMS details from Twillio. This functionality is magic.
        # log this number to track memory useage and monitor for memory leaks.
        # TODO take a timestamp snapshot here
        memory_footprint = sys.getallocatedblocks()
        logger.debug(f"Running program footprint is: {memory_footprint}")
        logger.info("Message received:")        
        # recover SMS details from Twillio. This functionality is magic.        
        sms_body = request.values.get("Body", None)
        sms_from = request.values.get("From", None)
        sms_MSID = request.values.get("MessageSid", None)
        logger.info(sms_MSID)
        logger.info(sms_from)
        logger.info(sms_body)

        # Generate an appropriate response (if any)
        if None in [sms_body, sms_from, sms_MSID]:
            logger.error('Invalid SMS received: "None" value encountered.')
            return "Unknown system error. SMS is invalid."

        reply = Respond_to(sms_MSID, sms_from, sms_body)
        if reply == "":
            reply = "Thank you."
        elif reply is None:
            logger.error('Respond_to function returned "None".')
            reply = "Unknown system error. Please try again."

        Send_SMS(reply, sms_from)
        logger.info("Updating database...")
        pickle.dump(players_database, open(DATABASE_PATHOBJ, "wb"))
        logger.info("SMS processing completed.")
        return reply

    logger.info("Flask app instantiated.")
    return ST_app

if __name__ == "__main__":
    try:
        setup_logger()
        # COMMANDS = initialize_commands() NOTE: I have no idea what ChatGPT was thinking this was
        SpeedTriviaApp = create_flask_app()
        logger.info("Starting SpeedTrivia application...")
        # Hand control to Flask
        SpeedTriviaApp.run()
        # Flask does not return here during exceptions or ctrl-c       
        logger.info("Program ended nominally.")
    except Exception as e:
        logger.error(f"Program terminated with exception: {str(e)}")
    finally:
        sys.exit(0)

""" This is my original code from 3 years previous
if __name__ == "__main__":
    try:

        # Begin logging definition
        logger.remove()  # removes the default console logger provided by Loguru.
        # I find it to be too noisy with details more appropriate for file logging.
        # TODO create a console output for logging events that are ERROR level and above.
        # create a new log file for each run of the program
        logger.add(
            f"{FILENAME}_{PROGRAM_START_TIME.strftime('%Y%m%d_%H%M%S%Z')}.log",
            rotation="Sunday",
            level="DEBUG",
            encoding="utf8",
        )
        # end logging setup
        logger.info("Program started.")

        logger.info("Program is being run as __main__")

        @logger.catch
        def ReturnCommandList(msid, sms_from, body_of_sms):
            return str(COMMANDS.keys())

        COMMANDS = {
            "Commands": ReturnCommandList,  # return this list of keys.
            "Webform": Send_Webform_help,  # provide a clickable link to the webform.
            "Common": Send_common_commands_help,  # provide help using most common commands.
            "Minus": RemoveReservation,  # remove a +1 from the caller's table.
            "Table": ReturnTableName,  # return callers table name.
            "Status": ReturnStatus,  # return caller status info.
            "Plus": AddReservation,  # add another +1 to the caller's table.
            "Funny": SuggestFunny,  # return a random "funny" team name from a list.
            "Serious": SuggestSerious,  # return a "serious" team name.
            "ChangeName": ChangePlayerName,  # delete the player name and ask for a new one.
            "ChangeTeam": SetTeamName,  # delete the team name and ask for a new one.
            "time": ReturnHelpInfo,  # return the HELP file with info on start time of game.
            "Helpme": ReturnHelpInfo,  # return the HELP file with info on using the app.
            "Shuffle": ShuffleTables,  # CONTROLLER ONLY: re-shuffle table assignments.
            "Start": StartGame,  # CONTROLLER ONLY: Lock-in the table assignments for this game night.
            "Size": ChangeTeamSize,  # CONTROLLER ONLY: Change the number of players per table.
            "Announcement": Send_Announcement,  # CONTROLLER ONLY: Make a SMS note to all registered players.
            "PlayersList": Send_players_list,  # CONTROLLER ONLY: Return a list of ALL players to CONTROLLER.
        }
        CONTROLLER_ONLY_COMMANDS = [
            "Announcement",
            "PlayersList",
            "Shuffle",
            "Start",
            "Size",
        ]

        Send_SMS("SpeedTrivia program start.", CONTROLLER)

        logger.info("Instantiating Flask App:")
        SpeedTriviaApp = Flask(__name__)
        logger.info(SpeedTriviaApp)

        @SpeedTriviaApp.route("/sms", methods=["GET", "POST"])
        def sms_reply():
            # Respond to incoming calls. This is the entrypoint for SpeedTrivia functionality.
            # log this number to track memory useage and monitor for memory leaks.
            # TODO take a timestamp snapshot here
            memory_footprint = sys.getallocatedblocks()
            logger.debug(f"Running program footprint is: {memory_footprint}")
            logger.info("Message received:")
            # recover SMS details from Twillio. This functionality is magic.
            sms_body = request.values.get("Body", None)
            sms_from = request.values.get("From", None)
            sms_MSID = request.values.get("MessageSid", None)
            logger.info(sms_MSID)
            logger.info(sms_from)
            logger.info(sms_body)
            # Generate an appropriate response (if any)
            if (sms_body == None) or (sms_from == None) or (sms_MSID == None):
                logger.error(f'Invalid SMS recieved. "None" value encountered.')
                reply = "Unknown system error. SMS is invalid."
            else:
                reply = Respond_to(sms_MSID, sms_from, sms_body)
            if reply == "":
                logger.info("No response needed.")
                reply = "Thank you."
            elif reply == None:
                logger.error(f'Respond_to function returned "None".')
                reply = "Unknown system error. Please try again."
            Send_SMS(reply, sms_from)
            logger.info("Updating database...")
            pickle.dump(players_database, open(DATABASE_PATHOBJ, "wb"))
            logger.info("Returning control to Flask.")
            # TODO take another time snapshot and log the time elapsed.
            return reply

        # Hand control to Flask
        SpeedTriviaApp.run()
        # Flask does not return here during exceptions or ctrl-c
        logger.info("Program ended nominally.")
        sys.exit(0)
    except Exception as e:
        logger.info("Program terminated with exception:")
        logger.info(str(e))
        sys.exit(0)
"""